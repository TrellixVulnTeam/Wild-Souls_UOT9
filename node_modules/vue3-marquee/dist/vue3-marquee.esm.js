import { defineComponent, ref, watch, computed, onMounted, unref, openBlock, createElementBlock, normalizeStyle, createElementVNode, isRef, createCommentVNode, renderSlot, Fragment, renderList } from 'vue';

const _hoisted_1 = {
  key: 0
};
const _hoisted_2 = {
  key: 0,
  class: "overlay"
};
const _hoisted_3 = {
  class: "marquee"
};
var script = /*#__PURE__*/defineComponent({
  props: {
    direction: {
      type: String,
      required: false,
      default: "normal"
    },
    duration: {
      type: Number,
      required: false,
      default: 20
    },
    delay: {
      type: Number,
      required: false,
      default: 0
    },
    loop: {
      type: Number,
      required: false,
      default: 0
    },
    clone: {
      type: Boolean,
      required: false,
      default: false
    },
    gradient: {
      type: Boolean,
      required: false,
      default: false
    },
    gradientColor: {
      type: Array,
      required: false,
      default: [255, 255, 255],
      validator: value => {
        if (value.length != 3) {
          return false;
        }

        if (typeof value[0] !== "number" || value[0] < 0 || value[0] > 255) {
          return false;
        }

        if (typeof value[1] !== "number" || value[1] < 0 || value[1] > 255) {
          return false;
        }

        if (typeof value[2] !== "number" || value[2] < 0 || value[2] > 255) {
          return false;
        }

        return true;
      }
    },
    gradientWidth: {
      type: String,
      required: false,
      default: "200px"
    },
    pauseOnHover: {
      type: Boolean,
      required: false,
      default: false
    },
    pauseOnClick: {
      type: Boolean,
      required: false,
      default: false
    }
  },

  setup(__props) {
    const props = __props;
    let cloneAmount = ref(0);
    let minWidth = ref("100%");
    let componentKey = ref(0);
    let containerWidth = ref(0);
    let contentWidth = ref(0);
    let ready = ref(false);
    let marqueeContent = ref(null);
    let marqueeContainer = ref(null);

    const ForcesUpdate = () => {
      componentKey.value++;
    };

    const checkForClone = async () => {
      setInterval(() => {
        minWidth.value = "0%";

        if (marqueeContent.value !== null && marqueeContainer.value !== null) {
          if (marqueeContent.value && marqueeContainer.value) {
            if ("clientWidth" in marqueeContent.value && "clientWidth" in marqueeContainer.value) {
              contentWidth.value = marqueeContent.value.clientWidth;
              containerWidth.value = marqueeContainer.value.clientWidth;
              const localCloneAmount = Math.ceil(containerWidth.value / contentWidth.value);
              cloneAmount.value = isFinite(localCloneAmount) ? localCloneAmount : 0;
              return cloneAmount.value;
            } else {
              minWidth.value = "100%";
              return 0;
            }
          } else {
            minWidth.value = "100%";
            return 0;
          }
        } else {
          minWidth.value = "100%";
          return 0;
        }
      }, 100);
    };

    watch(contentWidth, () => {
      if (props.clone) {
        ForcesUpdate();
      }
    });
    watch(containerWidth, () => {
      if (props.clone) {
        ForcesUpdate();
      }
    });
    const getCurrentStyle = computed(() => {
      let cssVariables = {
        "--duration": `${props.duration}s`,
        "--delay": `${props.delay}s`,
        "--direction": `${props.direction}`,
        "--pauseOnHover": `${props.pauseOnHover ? "paused" : "running"}`,
        "--pauseOnClick": `${props.pauseOnClick ? "paused" : "running"}`,
        "--loops": `${props.loop === 0 ? "infinite" : props.loop}`,
        "--gradient-color": `rgba(${props.gradientColor[0]}, ${props.gradientColor[1]}, ${props.gradientColor[2]}, 1), rgba(${props.gradientColor[0]}, ${props.gradientColor[1]}, ${props.gradientColor[2]}, 0)`,
        "--gradient-width": `${props.gradientWidth}`,
        "--min-width": `${minWidth.value}`
      };
      return cssVariables;
    });
    const showGradient = computed(() => {
      if (props.gradient) {
        return true;
      }

      return false;
    });

    const setupMarquee = async () => {
      if (props.clone) {
        await checkForClone();
        ForcesUpdate();
        ready.value = true;
      } else {
        ready.value = true;
      }
    };

    onMounted(setupMarquee);
    return (_ctx, _cache) => {
      return unref(ready) ? (openBlock(), createElementBlock("div", _hoisted_1, [(openBlock(), createElementBlock("div", {
        class: "vue3-marquee",
        style: normalizeStyle(unref(getCurrentStyle)),
        key: unref(componentKey)
      }, [createElementVNode("div", {
        class: "transparent-overlay",
        ref: (_value, _refs) => {
          _refs['marqueeContainer'] = _value;
          isRef(marqueeContainer) ? marqueeContainer.value = _value : marqueeContainer = _value;
        }
      }, null, 512), unref(showGradient) ? (openBlock(), createElementBlock("div", _hoisted_2)) : createCommentVNode("", true), createElementVNode("div", {
        class: "marquee",
        ref: (_value, _refs) => {
          _refs['marqueeContent'] = _value;
          isRef(marqueeContent) ? marqueeContent.value = _value : marqueeContent = _value;
        }
      }, [renderSlot(_ctx.$slots, "default")], 512), createElementVNode("div", _hoisted_3, [renderSlot(_ctx.$slots, "default")]), (openBlock(true), createElementBlock(Fragment, null, renderList(unref(cloneAmount), num => {
        return openBlock(), createElementBlock("div", {
          class: "marquee cloned",
          key: num
        }, [renderSlot(_ctx.$slots, "default")]);
      }), 128))], 4))])) : createCommentVNode("", true);
    };
  }

});

function styleInject(css, ref) {
  if ( ref === void 0 ) ref = {};
  var insertAt = ref.insertAt;

  if (!css || typeof document === 'undefined') { return; }

  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';

  if (insertAt === 'top') {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }

  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
}

var css_248z = "\n.vue3-marquee {\r\n  overflow-x: hidden !important;\r\n  display: flex !important;\r\n  flex-direction: row !important;\r\n  position: relative;\r\n  width: 100%;\n}\n.vue3-marquee:hover div {\r\n  animation-play-state: var(--pauseOnHover);\n}\n.vue3-marquee:active div {\r\n  animation-play-state: var(--pauseOnClick);\n}\n.marquee {\r\n  flex: 0 0 auto;\r\n  min-width: var(--min-width);\r\n  z-index: 1;\r\n  display: flex;\r\n  flex-direction: row;\r\n  align-items: center;\r\n  animation: scroll var(--duration) linear var(--delay) var(--loops);\r\n  animation-direction: var(--direction);\n}\n@keyframes scroll {\n0% {\r\n    transform: translateX(0%);\n}\n100% {\r\n    transform: translateX(-100%);\n}\n}\n.overlay {\r\n  position: absolute;\r\n  width: 100%;\r\n  height: 100%;\n}\n.transparent-overlay {\r\n  position: absolute;\r\n  width: 100%;\r\n  height: 100%;\n}\n.overlay::before,\r\n.overlay::after {\r\n  background: linear-gradient(to right, var(--gradient-color));\r\n  content: \"\";\r\n  height: 100%;\r\n  position: absolute;\r\n  width: var(--gradient-width);\r\n  z-index: 2;\n}\n.overlay::after {\r\n  right: 0;\r\n  top: 0;\r\n  transform: rotateZ(180deg);\n}\n.overlay::before {\r\n  left: 0;\r\n  top: 0;\n}\r\n";
styleInject(css_248z);

// Import vue component
// IIFE injects install function into component, allowing component
// to be registered via Vue.use() as well as Vue.component(),

var entry_esm = /*#__PURE__*/(() => {
  // Get component instance
  const installable = script; // Attach install function executed by Vue.use()

  installable.install = app => {
    app.component("Vue3Marquee", installable);
  };

  return installable;
})(); // It's possible to expose named exports when writing components that can
// also be used as directives, etc. - eg. import { RollupDemoDirective } from 'rollup-demo';
// export const RollupDemoDirective = directive;

export { entry_esm as default };
